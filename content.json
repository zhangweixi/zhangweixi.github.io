{"meta":{"title":"浓得化不开","subtitle":"","description":"zhang","author":"樵夫","url":"http://zhangweixi.github.io","root":"/"},"pages":[{"title":"about","date":"2019-01-05T09:51:05.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"about/index.html","permalink":"http://zhangweixi.github.io/about/index.html","excerpt":"","text":"关于我 body{ background:#000; } .bg{ position: fixed; top:0; left: 0; width:100vw; height:100vh; background-image:url('http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0105/11/15466607845577554_200869405_H800.jpg'); background-size: cover; background-position: center; display: flex; flex-direction: column; } .nav{ color:#fff; text-align: center; } a{ color:#fff; text-align: center; border:1px solid #999; padding:20px 30px; margin:10px; background:rgba(50,50,50,.6); border-radius: 5px; text-decoration: none; box-shadow: 2px 2px 15px #fff,-2px 0px 15px #fff; line-height: 50px; } .flex{ flex:1; } .title{ color:#fff; text-align: center; overflow: hidden; line-height: 150px; font-size: 40px; } “爱码仕\"一枚首页GitHub知乎"}],"posts":[{"title":"【顶置】日常事务安排","slug":"2050-01-01Day-Plan","date":"2050-01-01T00:00:00.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2050/01/01/2050-01-01Day-Plan/","link":"","permalink":"http://zhangweixi.github.io/2050/01/01/2050-01-01Day-Plan/","excerpt":"","text":"日期 计划 结果 备注 2019-03-13 对electron-Angular的整合熟悉其工作原理","categories":[{"name":"规划","slug":"规划","permalink":"http://zhangweixi.github.io/categories/规划/"}],"tags":[]},{"title":"element-admin 使用笔记","slug":"element-admin-使用笔记","date":"2021-04-19T15:26:26.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"2021/04/19/element-admin-使用笔记/","link":"","permalink":"http://zhangweixi.github.io/2021/04/19/element-admin-使用笔记/","excerpt":"一、API接口统一格式后台提供的API接口返回格式应该满足如下格式才可 { code: 20000, // 50008 50012 50014 都会造成重新登录 message: &#39;提示消息&#39;, data: {} }","text":"一、API接口统一格式后台提供的API接口返回格式应该满足如下格式才可 { code: 20000, // 50008 50012 50014 都会造成重新登录 message: &#39;提示消息&#39;, data: {} } 在授权后的请求中，将把token放在header的X-token中 header.X-Token = &#39;your token&#39;二、登录接口请求 { username: &#39;account&#39;, password: &#39;password&#39;, } 返回 { code: 20000, message: &#39;success&#39;, data: { token: &#39;your token&#39; } } 三、用户信息接口{ code: 20000, message: &#39;success&#39;, data: { name: &#39;name&#39;, avatar: &#39;头像&#39; } } 四、代理请求的时候一直pending详细文档”https://blog.csdn.net/yuse6262/article/details/107393394” 超时时候 proxy: { &quot;/api&quot;: { target: &#39;http://127.0.0.1:8000&#39;, changeOrigin: true, } } 解决超时 proxy: { &quot;/api&quot;: { target: &#39;http://127.0.0.1:8000&#39;, changeOrigin: true, // 由于vue中使用了body-parser 导致http中的body被序列化两次，从而使得配置代理后后端无法获取body中的数据 onProxyReq: function(proxyReq, req, res, options) { if (req.body) { const reg = new RegExp(&#39;application/json&#39;) if (reg.test(proxyReq.getHeader(&#39;Content-Type&#39;))) { const bodyData = JSON.stringify(req.body) proxyReq.setHeader(&#39;Content-Length&#39;, Buffer.byteLength(bodyData)) // stream the content proxyReq.write(bodyData) } } } } }","categories":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/tags/JS/"}]},{"title":"Linux便签","slug":"Linux标签","date":"2020-05-29T16:29:44.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/05/29/Linux标签/","link":"","permalink":"http://zhangweixi.github.io/2020/05/29/Linux标签/","excerpt":"","text":"使用PHP调用shell输出到指定文件&lt;?php $cmd = &quot;ls / &gt; outfile 2&gt;&amp;1&quot;; exec($cmd);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhangweixi.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/tags/linux/"}]},{"title":"EGG实践笔记","slug":"EGG实践笔记","date":"2020-05-18T14:47:08.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/05/18/EGG实践笔记/","link":"","permalink":"http://zhangweixi.github.io/2020/05/18/EGG实践笔记/","excerpt":"","text":"进制数据库字段将驼峰自动转换为下划线,设置：underscored:false 数据库进制自动转换为复数：freezeTableName： true 自定义数据库名称：tableName: xxx 调用service的方式为ctx.service.xxxx.method(),这里的xxxx是某个服务的文件名字，而不是服务的类名","categories":[],"tags":[]},{"title":"MySQL超过最大连接数量","slug":"MySQL超过最大连接数量","date":"2020-05-12T16:08:41.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/05/12/MySQL超过最大连接数量/","link":"","permalink":"http://zhangweixi.github.io/2020/05/12/MySQL超过最大连接数量/","excerpt":"","text":"报错SQLSTATE[HY000] [1129] Host &#39;172.20.0.1&#39; is blocked because of many connection errors; unblock with &#39;mysqladmin flush-hosts&#39; (SQL: select * from `user` where `openid` = oQxMh5b_yYB6YjK74C5l73T5vGZ0 limit 1) 环境docker mysql8几乎处于无人使用的状态 解决flush hosts; 为什么会发生这样的问题呢？","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"中断函数的坑","slug":"中断函数的坑","date":"2020-05-09T17:18:49.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"2020/05/09/中断函数的坑/","link":"","permalink":"http://zhangweixi.github.io/2020/05/09/中断函数的坑/","excerpt":"","text":"在嵌入式项目中，中断函数可以任意写，但是中断号却是唯一的，如果写了两个中断，将会导致后面的一个函数覆盖掉原来的中断，所以，在嵌入式项目中，最好把那些与项目无关的列子去掉","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://zhangweixi.github.io/categories/嵌入式/"}],"tags":[]},{"title":"项目之问","slug":"项目之问","date":"2020-04-28T11:41:04.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"2020/04/28/项目之问/","link":"","permalink":"http://zhangweixi.github.io/2020/04/28/项目之问/","excerpt":"","text":"如果你的服务停止了，你知道吗？ 你的服务器的CPU,内存，带宽是否满足服务需求，或者是否存在浪费资源的现象呢？ 服务器上是否存在过多重复的静态资源？ 服务器是否存在垃圾文件，即以后永远都不会再用到的文件 项目中使用各种语言相同工作方式的加密方式，以便同一个项目使用不同的语言的时候造成数据间无法共享","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://zhangweixi.github.io/categories/项目管理/"}],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://zhangweixi.github.io/tags/项目管理/"}]},{"title":"JS async 与 wait 实验笔记","slug":"JS-async-与-wait-实验笔记","date":"2020-04-27T17:30:26.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/04/27/JS-async-与-wait-实验笔记/","link":"","permalink":"http://zhangweixi.github.io/2020/04/27/JS-async-与-wait-实验笔记/","excerpt":"","text":"条件你需要先了解Promise的使用方式 asyncasync是一个函数修饰符，使得这个函数返回的是promise,如： async function demo1(){ return &quot;message&quot;; } /*类似于*/ function demo2(){ return new Promise(function(resolve,reject){ //success resolve(&#39;message&#39;); }); } //返回类型 console.log(typeof demo1()); //Promise { &#39;message&#39; } console.log(typeof demo2()); //object //调用 demo1().then(function(msg){ }); 看到上面的typeof demo1()了吧，返回的是一个promise,所以他自然是可以调用then方法的 那么问题来了，这里的then方法何时触发，因为这里的then其实就是promise中调用了resolve,可是async的resolve是何时触发的呢，那就是这个函数执行完毕，就会触发，这个触发的过程是隐形的，代码不可见的。 那么then()回调里的msg是从哪里来的呢，这是来自原demo1函数里的返回值 //==============无返回时的情况============ async function demo2(){ } demo2().then(msg=&gt;{console.log(msg);}); //打印结果：undefined //==============返回字符时的情况============ async function demo3(){ return &quot;lalala&quot;; } demo3().then(msg=&gt;{console.log(msg)}); //打印结果：lalala //==============返回Promise时的情况============ async function demo4(){ return new Promise(function(resolve,reject){ resolve(&#39;hahaha&#39;); }) } demo4().then(msg=&gt;{console.log(msg)}); //打印结果：hahaha //==============多个Promise时的情况============ async function demo5(){ const p1 = new Promise(function(resolve,reject){ resolve(&#39;aaaaa&#39;); }); const p2 = new Promise(function(resolve,reject){ resolve(&#39;bbbbb&#39;); }) return p1; } demo5().then(msg =&gt; console.log(msg)); //打印结果：aaaaa //=========返回非promise但有then方法时的情况======== async function demo6(){ return { then(callback){ callback(&#39;cccc&#39;); } } } demo6().then(msg=&gt;console.log(msg)); //打印结果：cccc 由上面的实验可以看出，如果async函数返回的是字符串，那么它将把字符串当做resolve的参数，如果返回是的一个promise，那么将用这个promise替换掉自己默认的promise，但是从最后一个实例看出来，返回的对象只要含有then方法，就可以覆盖async本身的then waitawait只能在async函数中使用wait就是要等，什么情况下需要等呢，同步需要等吗，不需要，因为同步本来就是顺序执行的，wait的目的就是要将异步变为同步,wait等待的对象需要时异步执行的对象，同时wait也需要在异步环境中才有效，即async函数中 //demo6().then(msg=&gt;console.log(msg)); function demo7(){ await new Promise(function(resolve,reject){ setTimeout(() =&gt; { resolve(&#39;1秒钟后执行&#39;); }, 1000); }) } demo7(); //报错：SyntaxError: await is only valid in async function async function demo8(){ return await new Promise(function(resolve,reject){ setTimeout(() =&gt; { resolve(&#39;1秒钟后执行&#39;); }, 1000); }) } demo8();//打印结果：1秒钟后执行 async function demo9(){ return await 5+5; } demo9().then(msg=&gt;console.log(msg));//打印结果：10 由上可知，wait只能在async函数中运行，但是wait后面的等待是否是Promise并没有任何关系 await返回的是异步执行后的结果，不再需要then下面，来验证wait发生的作用是什么 async function asyncSay(msg,ms){ return new Promise(function(resolve,reject){ setTimeout(function(){ resolve(msg); },ms); }); } async function demo10(){ const res = asyncSay(&#39;say1&#39;,1000); console.log(res); //Promise { &lt;pending&gt; } } async function demo10(){ const res = await asyncSay(&#39;say1&#39;,1000); console.log(res); //say1 } 由上看出，当有await时，await作用的对象返回的是promise的resolve后的值，而没有的时候，则是promise本身，这就体现出来了，以前要获取异步的结果，需要调用then方法才行，现在就不需要了 wait后的方法是同步执行的async function asyncSay(msg,ms){ return new Promise(function(resolve,reject){ setTimeout(function(){ console.log(ms,&#39;---&#39;,msg); resolve(msg); },ms); }); } async function demo11(){ asyncSay(&#39;msg1&#39;,2000); asyncSay(&#39;msg2&#39;,1000); } demo11(); /* 打印结果 1000 --- msg2 2000 --- msg1 */ async function demo12(){ asyncSay(&#39;msg1&#39;,2000); asyncSay(&#39;msg2&#39;,1000); } demo12(); /* 打印结果 2000 --- msg1 1000 --- msg2 */ 由上面的实验可知，加了wait的函数将把异步任务变成同步来执行，谁在前谁就先执行 另外一个奇怪的现象async function demo13(){ new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{console.log(2000);},2000); }); new Promise((resoleve,reject)=&gt;{ setTimeout(()=&gt;{console.log(1000);},1000); }); } demo13(); /* 打印结果 1000 2000 */ async function demo14(){ await new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{console.log(2000);},2000); }); await new Promise((resoleve,reject)=&gt;{ setTimeout(()=&gt;{console.log(1000);},1000); }); } demo14(); /* 打印结果 2000 */ 上面这个加了await,只执行了第一个Promise，为什么呢？？？？","categories":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/tags/JS/"}]},{"title":"GIT配置ssh操作","slug":"GIT配置ssh操作","date":"2020-04-23T13:34:38.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/04/23/GIT配置ssh操作/","link":"","permalink":"http://zhangweixi.github.io/2020/04/23/GIT配置ssh操作/","excerpt":"","text":"生成及添加公钥https://gitee.com/help/articles/4181#article-header0 新项目Clone使用git上面的SSH方式，而不是https方式， 如果已经存在了项目，更新Git的操作方式为SSHgit remote remove origin #删除旧的更新方式 git remote add origin git@github.com:Username/Your_Repo_Name.git #更新为正式的方式 git branch --set-upstream-to=origin/master master #设置新的方式生效","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/tags/工具/"}]},{"title":"egg框架练手笔记","slug":"egg框架练手笔记","date":"2020-04-17T10:46:19.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"2020/04/17/egg框架练手笔记/","link":"","permalink":"http://zhangweixi.github.io/2020/04/17/egg框架练手笔记/","excerpt":"","text":"试试","categories":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/tags/JS/"}]},{"title":"记element-ui checkbox无法选中","slug":"记element-ui-checkbox无法选中","date":"2020-04-09T15:08:17.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"2020/04/09/记element-ui-checkbox无法选中/","link":"","permalink":"http://zhangweixi.github.io/2020/04/09/记element-ui-checkbox无法选中/","excerpt":"","text":"element-ui在某些情况下无法选中，本文记录一些自己遇到的问题 &lt;el-form-item label=&#39;选项&#39;&gt; &lt;el-checkbox-group v-model=&quot;form.type&quot;&gt; &lt;el-checkbox v-for=&quot;(item,index) in types&quot; :key=&quot;index&quot; :label=&quot;item.name&quot; :value=&quot;item.value&quot; name=&quot;type&quot;&gt; &lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;script&gt; export default{ data(){ return { types:[{name:&#39;往期&#39;,value:&#39;history&#39;},{name:&#39;VIP&#39;,value:&#39;vip&#39;},{name:&#39;推荐&#39;,value:&#39;recommend&#39;},{name:&#39;顶部&#39;,value:&#39;top&#39;}], } }, methods:{ async getCourse(){ const {data:{code,msg,book}} = await getCourse(this.id); //可以 book.type = []; this.form = book; //错误 //this.form = book; //this.form.type = []; } } } &lt;/script&gt;","categories":[],"tags":[]},{"title":"Apache配置系列","slug":"20200401Apache配置系列","date":"2020-04-01T18:07:18.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/04/01/20200401Apache配置系列/","link":"","permalink":"http://zhangweixi.github.io/2020/04/01/20200401Apache配置系列/","excerpt":"","text":"一、配置反向代理 在有箭头的地方最好保留一个空格 course后面不要带/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhangweixi.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/tags/linux/"}]},{"title":"PHP7.4安装时遇到的问题","slug":"20200401PHP7-4安装时遇到的问题","date":"2020-04-01T16:41:41.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/04/01/20200401PHP7-4安装时遇到的问题/","link":"","permalink":"http://zhangweixi.github.io/2020/04/01/20200401PHP7-4安装时遇到的问题/","excerpt":"","text":"1.安装oniguruma看这里 2.安装mbstring扩展在configure时加上 –with-php-config phpize ./configure --with-php-config=to/php/config/path(这里是自己的路径) 3.安装libiconv看这里","categories":[{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/tags/PHP/"}]},{"title":"vmware安装vmware-tools","slug":"2020-03-29vmware安装vmware-tools","date":"2020-03-29T19:18:37.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/03/29/2020-03-29vmware安装vmware-tools/","link":"","permalink":"http://zhangweixi.github.io/2020/03/29/2020-03-29vmware安装vmware-tools/","excerpt":"","text":"废话少说，直接开始 1.找到包含vmware-tools的软件包很多教程一来就是如何如何安装，问题是现在没有这个软件呀，怎么安装？打开vmware这个软件的安装目录，搜索该目录下有个叫linux.iso的文件，这家伙里面就包括了所需要的安装脚步 2.把这个包弄到虚拟机里面去既然是iso文件，那就需要用虚拟光驱了 3.执行安装文件正式安装之前，强烈建议你批量安装这些工具，免得安装过程中缺少依赖不断报错 yum -y install perl gcc gcc-c++ make cmake kernel kernel-headers kernel-devel net-tools 3.配置共享文件后面的看这里吧","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhangweixi.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/tags/linux/"}]},{"title":"STM32HAL库串口中断函数分析","slug":"2020-03-24STM32HAL库串口中断函数分析","date":"2020-03-24T23:40:59.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/03/24/2020-03-24STM32HAL库串口中断函数分析/","link":"","permalink":"http://zhangweixi.github.io/2020/03/24/2020-03-24STM32HAL库串口中断函数分析/","excerpt":"","text":"1.第一步 USART1_IRQHandler如果开启了中断，当中断发生时，程序将会进入到这个函数中来，这个函数是一个若函数，已经在启动文件中有定义，如果开发者没有定义自己的回调，那么将会进入这个回调中 2.第二步 HAL_UART_IRQHandler从名字可以看出，这个函数是hal库函数，用户可在第一步中调用本函数，这个函数里处理了接受中断和发送中断的一些共同的操作，再本函数里，识别出是发送还是接收回调，然后调用相应的回调3.第三步 UART_Receive_IT如果第二步识别出是接收回调，那么将会调用本函数，本函数会处理所有uart的接收中断公共事件，然后再调用具体的处理用户逻辑的函数4.第四部 HAL_UART_RxCpltCallback用户的逻辑函数是一个若函数，如果用户不定义的话，将会进入初始化的函数中","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://zhangweixi.github.io/categories/嵌入式/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://zhangweixi.github.io/tags/STM32/"}]},{"title":"指针一定比变量快吗","slug":"2020-30-23C指针并不是一定比使用变量快","date":"2020-03-23T18:23:18.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/03/23/2020-30-23C指针并不是一定比使用变量快/","link":"","permalink":"http://zhangweixi.github.io/2020/03/23/2020-30-23C指针并不是一定比使用变量快/","excerpt":"","text":"不一定","categories":[{"name":"C","slug":"C","permalink":"http://zhangweixi.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://zhangweixi.github.io/tags/C/"}]},{"title":"关于C的疑惑","slug":"2020-03-23-关于C的疑惑","date":"2020-03-23T18:10:11.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/03/23/2020-03-23-关于C的疑惑/","link":"","permalink":"http://zhangweixi.github.io/2020/03/23/2020-03-23-关于C的疑惑/","excerpt":"","text":"1.为什么字符串无法直接赋值给字符数组为什么上面错误，下面正确，这是因为当把字符串赋值给某个变量时，其实是把字符串的首地址给那个变量，既然是地址，那肯定只能给指针变量了，char names[] 是一个字符数组，char *names[]是字符型的指针数组 char names[] = { &quot;Zara Ali&quot;, &quot;Hina Ali&quot;, &quot;Nuha Ali&quot;, &quot;Sara Ali&quot;, }; char *names[] = { &quot;Zara Ali&quot;, &quot;Hina Ali&quot;, &quot;Nuha Ali&quot;, &quot;Sara Ali&quot;, }; 同样类似的还有下面这样的情况 typedef struct { char name[]; int price; }Book; Book book1; book1.price = 20; book1.name = &quot;english&quot;; //上面的将会编译出错，原因同上，正确的方式应该是 strcpy(book1.name,&quot;english&quot;); 2.类型决定了变量存储的布局我们知道类型会影响变量占用空间的大小，如int占用4个字节，char占用一个字节，可是，类型是如何决定布局的呢，布局指的是什么？又有哪些不同的布局方式？","categories":[{"name":"C","slug":"C","permalink":"http://zhangweixi.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://zhangweixi.github.io/tags/C/"}]},{"title":"STM32中断","slug":"2020-03-13STM32中断","date":"2020-03-13T22:48:41.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/03/13/2020-03-13STM32中断/","link":"","permalink":"http://zhangweixi.github.io/2020/03/13/2020-03-13STM32中断/","excerpt":"","text":"1.外部中断与GPIO关系stm32有22个外部中断，这里的外部，并不仅仅是指外部GPIO产生的才叫外部中断，EXTIO-EXTI15是链接到外部的GPIO的，所以，对于每一个EXTI来说，GPIO是需要配置的，而不是固定好了的。 外部GPIO触发只有上升沿触发和下降沿触发，可以选择其一，或者两者都选择，但是没有低电平触发 2.串口波特率计算方式","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://zhangweixi.github.io/categories/嵌入式/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://zhangweixi.github.io/tags/STM32/"}]},{"title":"STM32学习过程问题收集","slug":"STM32学习过程问题收集","date":"2020-03-06T10:41:08.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"2020/03/06/STM32学习过程问题收集/","link":"","permalink":"http://zhangweixi.github.io/2020/03/06/STM32学习过程问题收集/","excerpt":"","text":"1.J-LINK原本是要收费的，而且费用不菲，因而出现很多盗版，高版本的J-LINK驱动做了盗版检测，低版本的没有检测这个功能 解决办法，安装一个低版本的驱动就行，看这里","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://zhangweixi.github.io/categories/嵌入式/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://zhangweixi.github.io/tags/STM32/"}]},{"title":"MDK安装设备扩展包","slug":"2020-03-05MDK安装设备扩展包","date":"2020-03-05T21:12:40.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2020/03/05/2020-03-05MDK安装设备扩展包/","link":"","permalink":"http://zhangweixi.github.io/2020/03/05/2020-03-05MDK安装设备扩展包/","excerpt":"","text":"最简单的方式就是使用MDK自带的扩展包管理工具安装： 打开 https://www.keil.com/dd2 找到要下载的内容下载，下载后不用解压，打开方法一的界面，选择File-&gt;Import","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://zhangweixi.github.io/categories/嵌入式/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://zhangweixi.github.io/tags/STM32/"}]},{"title":"STM32模板文件构建","slug":"STM32模板文件构建","date":"2020-03-04T22:43:23.000Z","updated":"2021-04-19T07:47:00.728Z","comments":true,"path":"2020/03/04/STM32模板文件构建/","link":"","permalink":"http://zhangweixi.github.io/2020/03/04/STM32模板文件构建/","excerpt":"","text":"在学习STM32的时候，对一个新手很困难的一个问题就是如何构建一个模板目录，而一般教程则会告诉你，下载什么东西，然后将什么目录的文件拷贝到你的项目的哪个目录中去。比如： 例：如何构建STM32F407的工程目录 访问：www.stmcu.org。 右上角搜索框输入 stm32cubef4，点击搜索在弹出的搜索结果页中，文档栏第一个有stm32cubef4，点击进去即可找到下载页面。 新建一个工程目录，如图 解压stm32cubef4,将STM32Cube_FW_F4_V1.24.1\\Drivers\\STM32F4xx_HAL_Driver\\Src--&gt;FWLIB\\Src STM32Cube_FW_F4_V1.24.1\\Drivers\\STM32F4xx_HAL_Driver\\Inc--&gt;FWLIB\\Inc STM32Cube_FW_F4_V1.24.1\\Drivers\\CMSIS\\Device\\ST\\STM32F4xx\\Source\\Templates\\arm\\startup_stm32f407xx.s,STM32Cube_FW_F4_V1.24.1\\Drivers\\CMSIS\\Include[ cmsis_armcc.h， cmsis_armclang.h ， cmsis_compiler.h ， cmsis_version.h ， mpu_armv7.h ， core_cm4.h]-&gt;CORE\\ ``` 如果遇到新的板子怎么办还是模拟这个路径去寻找吗？如果不对呢？如何获得权威的信息来源呢？ 正确方式 到官网下载相应的扩展软件包，如STM32CubeF4，搜出来会很多，找到正确的 解压后内部有一个Documentation文件夹，内部有一个文档，文档里面说明了一个简单的列子，根据说明打开这个工程，看看这里面是如何构建的一个工程 如果重新编译后在这个目录找不到相应的头文件，按下面操作，一定就能够找到了 至此，一个完整的构建模板的流程至此完毕","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://zhangweixi.github.io/categories/嵌入式/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://zhangweixi.github.io/tags/STM32/"}]},{"title":"conda在shell脚本中提示未初始化","slug":"2019-09-17-conda在shell脚本中提示未初始化","date":"2019-09-17T11:59:40.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/09/17/2019-09-17-conda在shell脚本中提示未初始化/","link":"","permalink":"http://zhangweixi.github.io/2019/09/17/2019-09-17-conda在shell脚本中提示未初始化/","excerpt":"","text":"初始安装时候自动初始化每个用户在使用conda的时候，都必须要指定一种shell类型，如bash,fish，tcsh,zsh等，当在安装conda的时候，其实安装过程中已经进行了这样的初始化操作。因而当使用conda activate 命令的时候，能够成功的执行。假设这个时候使用的是root用户进行安装的。 除了base环境外，现在，新建一个环境 [root]# conda create -n flask python=2.7 #现在有两个虚拟环境 [root]# conda env list base * /usr/local/anaconda3 flask /usr/local/anaconda3/envs/flask #### 给其他用户初始化conda现在，我们进行以下操作： 切换到用户www 查看conda有哪些环境 进入flask环境[root]# su www [www]# conda env list base * /usr/local/anaconda3 flask /usr/local/anaconda3/envs/flask [www]# conda activate flaskCommandNotFoundError: Your shell has not been properly configured to use ‘conda activate’.To initialize your shell, run $ conda init &lt;SHELL_NAME&gt;Currently supported shells are: bash fish tcsh xonsh zsh powershell See ‘conda init –help’ for more information and options. IMPORTANT: You may need to close and restart your shell after running ‘conda init’. 从以上结果可以看出，conda是生效的，但是当前用户却无法激活某个环境，那是因为目前还没有初始化当前用户在使用conda时应该使用什么shell.查看用户目录下的.bashrc文件，内容如下： ```bash [www]# vim ~/.bashrc #============================内容如下======================================= # .bashrc # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi # Uncomment the following line if you don&#39;t like systemctl&#39;s auto-paging feature: # export SYSTEMD_PAGER= # User specific aliases and functions ~ #========================================================================= 如果你的情况如上，没有关于任何conda init相关的任何内容，那么就表明确实没有初始化，现在来初始化： [zhangweixi@dev001 ~]$ conda init bash no change /usr/local/anaconda3/condabin/conda no change /usr/local/anaconda3/bin/conda no change /usr/local/anaconda3/bin/conda-env no change /usr/local/anaconda3/bin/activate no change /usr/local/anaconda3/bin/deactivate no change /usr/local/anaconda3/etc/profile.d/conda.sh no change /usr/local/anaconda3/etc/fish/conf.d/conda.fish no change /usr/local/anaconda3/shell/condabin/Conda.psm1 no change /usr/local/anaconda3/shell/condabin/conda-hook.ps1 no change /usr/local/anaconda3/lib/python3.7/site-packages/xontrib/conda.xsh no change /usr/local/anaconda3/etc/profile.d/conda.csh modified /home/zhangweixi/.bashrc ==&gt; For changes to take effect, close and re-open your current shell. &lt;== 如果输出这样的信息，表示初始化成功，再看.bashrc文件，内容如下： [zhangweixi@dev001 ~]$ vim ~/.bashrc #=======================内容如下=========================== # .bashrc # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi # Uncomment the following line if you don&#39;t like systemctl&#39;s auto-paging feature: # export SYSTEMD_PAGER= # User specific aliases and functions # &gt;&gt;&gt; conda initialize &gt;&gt;&gt; # !! Contents within this block are managed by &#39;conda init&#39; !! __conda_setup=&quot;$(&#39;/usr/local/anaconda3/bin/conda&#39; &#39;shell.bash&#39; &#39;hook&#39; 2&gt; /dev/null)&quot; if [ $? -eq 0 ]; then eval &quot;$__conda_setup&quot; else if [ -f &quot;/usr/local/anaconda3/etc/profile.d/conda.sh&quot; ]; then . &quot;/usr/local/anaconda3/etc/profile.d/conda.sh&quot; else export PATH=&quot;/usr/local/anaconda3/bin:$PATH&quot; fi fi unset __conda_setup # &lt;&lt;&lt; conda initialize &lt;&lt;&lt; 由此可以看出，conda在该文件中写入了一些东西，那么这个试试来试试能激活环境吗？ [zhangweixi@dev001 ~]$ conda activate flask CommandNotFoundError: Your shell has not been properly configured to use &#39;conda activate&#39;. To initialize your shell, run $ conda init &lt;SHELL_NAME&gt; Currently supported shells are: - bash - fish - tcsh - xonsh - zsh - powershell See &#39;conda init --help&#39; for more information and options. IMPORTANT: You may need to close and restart your shell after running &#39;conda init&#39;. 妹的，还是不行呀？到底啥原因？如果你切换当前账号到root,然后再切换回来www用户来，再执行conda activate flask，你会发现，成功的激活环境。原因在于：当某用户进入系统后，会自动执行用户目录下的.bashrc文件，当第一次初始化conda init后，把相应的内容出入了.bashrc文件，可是这些代码并没有在环境中执行，要想立刻生效，可以通过手动执行这个脚本：source ~/.bashrc,这样，再去激活环境就没有什么问题了。 在shell脚本中激活环境现在来编写一个很简单的shell，如下： [www]# vim test.sh #==================内如如下============== #!/bin/bash conda activate flask #====================内容结束=========== [www]# bash test.sh CommandNotFoundError: Your shell has not been properly configured to use &#39;conda activate&#39;. To initialize your shell, run $ conda init &lt;SHELL_NAME&gt; Currently supported shells are: - bash - fish - tcsh - xonsh - zsh - powershell See &#39;conda init --help&#39; for more information and options. IMPORTANT: You may need to close and restart your shell after running &#39;conda init&#39;. 操蛋，居然不行，直接告诉如何操作把，把.bashrc文件中初始化conda的那一段代码复制到test.sh文件的上面，变成这样: #=========================test.sh内如如下========================= #!/bin/bash # &gt;&gt;&gt; conda initialize &gt;&gt;&gt; # !! Contents within this block are managed by &#39;conda init&#39; !! __conda_setup=&quot;$(&#39;/usr/local/anaconda3/bin/conda&#39; &#39;shell.bash&#39; &#39;hook&#39; 2&gt; /dev/null)&quot; if [ $? -eq 0 ]; then eval &quot;$__conda_setup&quot; else if [ -f &quot;/usr/local/anaconda3/etc/profile.d/conda.sh&quot; ]; then . &quot;/usr/local/anaconda3/etc/profile.d/conda.sh&quot; else export PATH=&quot;/usr/local/anaconda3/bin:$PATH&quot; fi fi unset __conda_setup # &lt;&lt;&lt; conda initialize &lt;&lt;&lt; conda activate flask which python #==============================内容结束==================== [www]# bash test.sh /usr/local/anaconda3/envs/flask/bin/python 有此可见，conda激活成功，只不过是shell执行完毕后，环境也就自动销毁了，但是在shell的过程当中，还是处于所激活的环境的。","categories":[{"name":"Python","slug":"Python","permalink":"http://zhangweixi.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zhangweixi.github.io/tags/python/"}]},{"title":"详解MySQL的SQL Modes","slug":"2019-08-21详解MySQL的SQL-Modes","date":"2019-08-21T16:06:46.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/08/21/2019-08-21详解MySQL的SQL-Modes/","link":"","permalink":"http://zhangweixi.github.io/2019/08/21/2019-08-21详解MySQL的SQL-Modes/","excerpt":"","text":"段落引用根据MySQL手册翻译而来https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html MODELES集合ANSI = REAL_AS_FLOAT, PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, and ONLY_FULL_GROUP_BY TRADITIONAL = STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, and NO_ENGINE_SUBSTITUTION 所有的SQL MODELS列表 ALLOW_INVALID_DATESmysql会对日期进行合法性检查，对应的字段为date,datetime。当添加上此项的时候，只会检查月份在1-12之间，日期在1-31之间，如果你插入一个无效的日期，将会对其进行改变，如：2004-04-31（4月份不存在31号）自动改变成0000-00-00，无任何报错，如果是严格模式的话，将直接报错。 ANSI_QUOTES当设置了这个后，双引号【“】将被当做【`】来使用，即当做关键的标识符SELECT &quot;TEST&quot;; # 错 SELECT `TEST`; # 错 SELECT &#39;TEST&#39;; # 对 ERROR_FOR_DIVISION_BY_ZERO被0除是否报错，但是实际测试下来，没有发现在什么情况下报错。SET SQL_MODE=&quot;&quot;; SELECT 10/0; # 结果为null HIGH_NOT_PRECEDENCE对于这一项，没有找到实际的用途，只发现了区别```SQLSET sql_mode = ‘’;SELECT NOT 1 BETWEEN -5 AND 5; # 可以理解为判断这句话：1不是在-5和5之间，错误，所以结果0 -&gt; 0SELECT NOT 10 BETWEEN -5 AND 5; # 可以理解为判断这句话：10不是在-5和5之间，正确，所以结果1-&gt; 1 SET sql_mode = ‘HIGH_NOT_PRECEDENCE’; 可以理解为判断这句话：1不是在-5和5之间，这是错误的，但是结果却是正确的SELECT NOT 1 BETWEEN -5 AND 5;-&gt; 1SELECT NOT 10 BETWEEN -5 AND 5;-&gt; 1 5. IGNORE_SPACE 在使用函数的时候忽略函数名和左括号【（】之间的空格。 ```sql mysql&gt; set sql_mode = &quot;STRICT_TRANS_TABLES&quot;; Query OK, 0 rows affected, 1 warning (0.01 sec) mysql&gt; select max (age) from user; ERROR 1630 (42000): FUNCTION test.max does not exist. Check the &#39;Function Name Parsing and Resolution&#39; section in the Reference Manual mysql&gt; set sql_mode = &quot;IGNORE_SPACE&quot;; Query OK, 0 rows affected (0.00 sec) mysql&gt; select max (age) from user; +-----------+ | max (age) | +-----------+ | 3 | +-----------+ 1 row in set (0.00 sec)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"基于Docker的Mysql使用过程（三）——数据迁移","slug":"2019-08-20基于Docker的Mysql使用过程（三）——数据迁移","date":"2019-08-20T13:57:38.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/08/20/2019-08-20基于Docker的Mysql使用过程（三）——数据迁移/","link":"","permalink":"http://zhangweixi.github.io/2019/08/20/2019-08-20基于Docker的Mysql使用过程（三）——数据迁移/","excerpt":"","text":"情况说明目前要做的是数据迁移，而不是数据备份，即迁移成功后当前的Mysql就不再使用了，这样势必会影响到业务正常的运行。但是影响的程度也有多种选择： 当前业务任然可以使用查询业务 完全停止所有业务（最坏情况） 业务照常进行，再迁移成功后立刻将应用切换的新的库。（暂时不知是否能够保证在数据不发生错误的情况下进行）具体操作 锁定MySQL，禁止修改数据登录MySQL终端，将表加上读锁，使得当前的系统只能查询，而不能修改数据，特别注意，不要退出终端，退出后相当于释放了锁。 FLUSH TABLES WITH READ LOCK; 2. 使用mysqldump导出数据 ```shell mysqldump --databases youdbname -u user -ppassword &gt; /../db.sql3.在新的系统中恢复数据将db.sql拷贝到新系统，登录新的SQL客户端，导入数据，在此之前，你应当提前创建好数据库名称。 SOURCE /../db.sql 切换系统，释放锁将系的数据库配置切换到新的系统，然后将加锁的老MySQL系统解锁。UNLOCK TABLES; 特别注意事项在实施正式系统的数据迁移之前，务必先部署一个测试系统，等在测试系统中对迁移的流程走过一遍，并且系统能够正常运行之后，才迁移正式的系统的数据。不然当你将正式系统切换到新的数据库后，发现某些配置不对，版本不同造成的问题会使你措手不及，惊慌失措。比如在本次中就遇几个问题：1.sql_mode问题，遇到报错如下SQLSTATE[42000]: Syntax error or access violation: 1231 Variable &#39;sql_mode&#39; can&#39;t be set to the value of &#39;NO_AUTO_CREATE_USER&#39;&quot;) 解决方式1：将新的MySQL设置为：sql_model=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_ BY_ZERO,NO_ENGINE_SUBSTITUTION 设置之后发现还是不行，后经查阅，将应用系统改为非严格模式：strict=false2.现在位于Linux上的问题解决了，可是当我在Windows上连接时，却发现又产生新的账号问题；SQLSTATE[HY000] [2054] The server requested authentication method unknown to the client 很奇葩，windows上用cmd的客户端可以登录，但是系统却无法登陆，此时系统用户的加密方式已经改为mysql_native_password,但是任然报错。解决此问题的方式是，在MySQL配置文件中修改默认的认证加密方式，问题迎刃而解，配置如下：default_authentication_plugin=mysql_native_password","categories":[{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/categories/Docker/"},{"name":"MySQL","slug":"Docker/MySQL","permalink":"http://zhangweixi.github.io/categories/Docker/MySQL/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"基于Docker的Mysql使用过程（二）——修改配置","slug":"2019-08-20Centos7上基于Docker的Mysql使用过程（二）","date":"2019-08-20T10:38:15.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/08/20/2019-08-20Centos7上基于Docker的Mysql使用过程（二）/","link":"","permalink":"http://zhangweixi.github.io/2019/08/20/2019-08-20Centos7上基于Docker的Mysql使用过程（二）/","excerpt":"","text":"目标 修改容器的数据目录 修改配置文件 参考官方文档 一.添加额为的配置文件1.1、容器配置信息容器自身的配置文件为/etc/mysql/my.cnf,如果要想添加自己的配置，有两种办法，一是修改my.cnf,二是新增配置项到/etc/mysql/conf.d目录下面，my.cnf会将该目录下的所有文件都包含进去。所以现在在宿主机建立一个配置文件，然后映射到该目录下。新增配置分为复制文件和文件映射，为了以后修改方便，采用文件映射的方式。 ++包含这种思想是一种非常好的模式，通常要想去修改某个已有的东西会比较麻烦，但是如果只是新增或者删除一个东西则会变得非常简单++ 1.2、新增配置，生成binlog新建配置文件/xxx/my.cnf 二.修改默认的数据目录2.1查找信息登录容器查找MySQL的data目录，可以看见当前的目录是：/var/lib/mysql 三、执行命令，查看解决。3.1 将数据目录和文件目录一起映射 3.2 查看结果","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"},{"name":"Docker","slug":"MySQL/Docker","permalink":"http://zhangweixi.github.io/categories/MySQL/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"基于Docker的Mysql使用过程（一）——安装","slug":"2019-08-19Centos7上基于Docker的Mysql使用过程","date":"2019-08-19T16:12:43.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/08/19/2019-08-19Centos7上基于Docker的Mysql使用过程/","link":"","permalink":"http://zhangweixi.github.io/2019/08/19/2019-08-19Centos7上基于Docker的Mysql使用过程/","excerpt":"","text":"1.启动 [root@dev001 vhost]# docker run --name mysql -p 3308:3306 -itd -e MYSQL_ROOT_PASSWORD=xx mysql:8.0 67a5025a3a14ab815bd04e08a4c357d6e235db8f7c59f0432dc102ea2f2f2525 2.查看容器IP [root@dev001 vhost]# docker inspect mysql //找到networks字段 &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;244a2f6355b609ede5c8311c530516b7493175881d7777c53f497d3fbc56110f&quot;, &quot;EndpointID&quot;: &quot;90a9071b14f938083b807ae78d5bf88e292a3bc52286757929adedb0473d6693&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null } 3.在宿主机连接容器的mysql,发生错误[root@dev001 vhost]# mysql -h172.17.0.2 -uroot -p Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded: /usr/local/mysql/lib/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory 错误原因：在宿主机使用的mysql版本和容器内的mysql版本不一致，在mysql8中，mysql的密码的加密方式不一致，mysql8中的默认加密方式为：caching_sha2_password，而宿主机中找不到这种加密方式的库，所以报错。 解决方式：docker exec -it mysql2 /bin/bash # 进入mysql容器: mysql -uroot -pmima #进入mysql ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;你的密码&#39;; #修改密码和加密方式 flush privileges; #刷新权限 exit # 退出mysql exit # 退出容器 4.使用宿主机映射的端口登录启动容器的时候将宿主机的3307映射到了容器的3306，这个时候是可以使用宿主机的3307端口登录 [root@dev001 zhangweixi]# mysql -uroot -P 3307 -p Enter password: ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES) 然而，却登录失败了，这是因为使用本机登录的时候，mysql将默认host为localhost,此时对应的加密方式还是caching_sha2_password 5.其他不要忘记了服务器的防火墙端口设置和阿里云的安全组端口设置","categories":[{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/categories/Docker/"},{"name":"MySQL","slug":"Docker/MySQL","permalink":"http://zhangweixi.github.io/categories/Docker/MySQL/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"机器学习的准备工作","slug":"2019-08-11机器学习的准备工作","date":"2019-08-11T08:00:18.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/08/11/2019-08-11机器学习的准备工作/","link":"","permalink":"http://zhangweixi.github.io/2019/08/11/2019-08-11机器学习的准备工作/","excerpt":"","text":"1.收集数据这个工作应该放到平日来做，但是如果临时需要数据的话，可以在原始的数据上做一定的变动而得到更多的训练数据 2.提取特征提取特征的准则预处理数据1.标签类型转换# 标签转换成整形 import numpy as np from sklearn.preprocessing import LabelBinarizer # 标签转换器 from sklearn.preprocessing import LabelBinarizer # 标签转换器 from sklearn.neighbors import KNeighborsClassifier # KNN分类器 from sklearn.preprocessing import StandardScaler # 特征所放器 #################################### # 训练数据 #################################### X_train = np.array([ [158, 64], [170, 86], [183, 84], [191, 80], [155, 49], [163, 59], [180, 67], [158, 54], [170, 67] ]) y_train = [&#39;male&#39;, &#39;male&#39;, &#39;male&#39;, &#39;male&#39;, &#39;female&#39;, &#39;female&#39;, &#39;female&#39;,&#39;female&#39;, &#39;female&#39;] #################################### # 测试数据 #################################### X_test = np.array([[155, 70],[160, 50]]) #################################### # 特征缩放 #################################### ss = StandardScaler() X_train_scaled = ss.fit_transform(X_train) X_test_scaled = ss.transform(X_test) #################################### # 数据类型转换 #################################### lb = LabelBinarizer() y_train_binarized = lb.fit_transform(y_train) print(y_train_binarized) &quot;&quot;&quot; the output is : [[1] [1] [0] [0]] &quot;&quot;&quot; #################################### # 训练和预测 #################################### # 训练 k = 3 clf = KNeighborsClassifier(n_neighbors=k) clf.fit(X_train,y_train_binarized.reshape(1,-1)[0]) #预测 prediction_binarized = clf.predict(X_test) # 转换标签 prediction_binarized = prediction_binarized.reshape(1,-1)[0] y_test = lb.inverse_transform(prediction_binarized) print(y_test) 3.确定模型","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zhangweixi.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://zhangweixi.github.io/tags/机器学习/"}]},{"title":"PHP大数组，你得小心","slug":"2019-06-06PHP大数组，你值得小心","date":"2019-06-06T16:48:01.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/06/06/2019-06-06PHP大数组，你值得小心/","link":"","permalink":"http://zhangweixi.github.io/2019/06/06/2019-06-06PHP大数组，你值得小心/","excerpt":"","text":"关于内容存储你有没有想过，存储在电脑上的文件在编程时读入内存的大小会改变吗？你有没有想过，一个长长的字符串被拆分成多段后，他们占用的总的空间是一样的吗？ 源起现在所在的项目需要将数据解析成一定的格式来进行操作，所有的原始数据总的也不超过100M，但是在实际的运行过程中，出现过很多次内存溢出致使代码停止运行，开始以为仅仅100来M的数据，把内存调整到1G总是足足有余。可是1G，2G，最后甚至调整到了3G才没有出现类似的故障，后来细查下来，原来PHP中相同的数据量使用数组和字符来存储数据时所占用的内存有这么大的差异，故此记录之。 实验先来个对比吧 1.所有存入到一个字符串 $begin = (memory_get_usage())/1024/1024; echo &quot;begin:&quot;.$begin.&quot;\\n&quot;; $str = &quot;&quot;; for($i=0;$i&lt;200000;$i++) { $temp = md5($i); $str .= $temp.$temp.$temp; } $end = (memory_get_usage())/1024/1024; echo &quot;end:&quot;.$end; //结果如下 begin:0.36307525634766 end:20.363174438477 2.存入一维数组一维数组虽然和开始的字符串是同样多的内容，但是它所占用的内容已经多出17M，相应增加85%； $begin = (memory_get_usage())/1024/1024; echo &quot;begin:&quot;.$begin.&quot;\\n&quot;; $str = []; for($i=0;$i&lt;200000;$i++){ $temp = md5($i); array_push($str, $temp); array_push($str, $temp); array_push($str, $temp); } $end = (memory_get_usage())/1024/1024; echo &quot;end:&quot;.$end; //结果如下 begin:0.36358642578125 end:37.044853210449 3.存入二维数组二维数组虽然和开始的字符串是同样多的内容，但是它所占用的内容已经多出50M，相应增加250%； $begin = (memory_get_usage())/1024/1024; echo &quot;begin:&quot;.$begin.&quot;\\n&quot;; $str = []; for($i=0;$i&lt;200000;$i++){ $temp = md5($i); $arr = [$temp,$temp,$temp]; array_push($str, $arr); } $end = (memory_get_usage())/1024/1024; echo &quot;end:&quot;.$end; //结果如下 begin:0.36331176757812 end:70.924461364746 是什么造成如上的原因呢？。。。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/tags/PHP/"}]},{"title":"快速且优雅的切换注释","slug":"2019-05-16进行快速且优雅的注释切换","date":"2019-05-16T16:05:10.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/05/16/2019-05-16进行快速且优雅的注释切换/","link":"","permalink":"http://zhangweixi.github.io/2019/05/16/2019-05-16进行快速且优雅的注释切换/","excerpt":"","text":"有很多时候，当写好了一大段程序之后，然后进行测试，比如这样： function fun(){ //添加一份订单 $orderData = [...]; create_order($data); //发送一个邮件 $userId = 10; $email = Redis::get($userId); do1(); do2(); do3(); send_email($email,$msg); do_other_thing(); } 恰好当你测试的时候Redis服务器和邮件服务器都没有准备好（各种原因…），那么在测试的时候就不想要这段代码执行，但是有时候好了你又要让它执行，那就会涉及到经常的切换，你可以有一下几种做法: 1. 用if切换，缺点是不好看，最后还得统一缩进function fun(){ //添加一份订单 $orderData = [...]; create_order($data); //发送一个邮件 if(0){ $userId = 10; $email = Redis::get($userId); do1(); do2(); do3(); send_email($email,$msg); } do_other_thing(); } 2. 单行注释，这是最麻烦的，每次都要逐行添加或删除注释function fun(){ //添加一份订单 $orderData = [...]; create_order($data); //发送一个邮件 //$userId = 10; //$email = Redis::get($userId); //do1(); //do2(); //do3(); //send_email($email,$msg); do_other_thing(); } 3. 块注释，稍好，但是当切换的时候开头和结尾都要操作function fun(){ //添加一份订单 $orderData = [...]; create_order($data); //发送一个邮件 /* $userId = 10; $email = Redis::get($userId); do1(); do2(); do3(); send_email($email,$msg); */ do_other_thing(); } 4. 巧妙的快注释，切换时只需要注释开头添加 删 “/” OR 加 “/”function fun(){ //添加一份订单 $orderData = [...]; create_order($data); /*发送一个邮件 | 切换的时候只需要在本行开头删除/或添加/ $userId = 10; $email = Redis::get($userId); do1(); do2(); do3(); send_email($email,$msg); //*/ do_other_thing(); } 5. 来张鲜明的对比吧","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://zhangweixi.github.io/categories/小技巧/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://zhangweixi.github.io/tags/小技巧/"},{"name":"代码规范","slug":"代码规范","permalink":"http://zhangweixi.github.io/tags/代码规范/"}]},{"title":"记录第一个应用【时间手印】","slug":"2019-04-26记录第一个应用【时间手印】","date":"2019-04-26T13:35:40.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/04/26/2019-04-26记录第一个应用【时间手印】/","link":"","permalink":"http://zhangweixi.github.io/2019/04/26/2019-04-26记录第一个应用【时间手印】/","excerpt":"","text":"初衷为什么要做这么一个小应用呢？是源于自己平时的工作和学习需求。有个理论叫做“一万小时定律”，要成为某个领域的专家，至少需要在改方面投入1万个小时的练习。一万小时是多少呀，如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。哈哈，原来自己技艺不精，仅仅在时间上就是不达标的。这个应用就是专门用来记录你在某件事情上所花的总时间。在IOS的Appstore找了很多应用，都没有这个功能，所以特意制作了一个 应用领域 学习：必须你如果是一个想在职考研的人，那么你得保证一定的学习时间呀，你早上学，中午学，吃饭学，坐车学，可是到底总的学习了多少时间呢，尤其是那种不能在APP上学习的知识。 运动：如果你去跑步的话，是可以用一些APP的，可是如果是去健身房，那就可以用这个来记录呀。 总之，本应用主要在于统计你的零散的时间，目的不在于提醒，如果要做日程计划和事件清单的话并不推荐 过程第一次做一个上线并且可以提供给人使用的工具，开始的时候本来预计一天就搞定了，可是弄下来足足花了一个星期，由此可见，虽然已经有了几年的开发经验，但是对于项目的时间评估是很不到位的。从这个过程中也反映出另外一个问题，一些不常用的东西很快就会忘掉，比如对于小程序的网络接口请求是需要在后台配置的，之前做个，但是忘记了，搞了半天，调试没有问题，正式就各种问题，原来是没有配置。 由此而引发一个问题，平时学习应该多在什么方面多花时间，新的事物不断出现，这些事物在某些方面或许要胜过一些旧的事物，可是还是应该在之前的那个成熟的，并且应用最多的事物上面多花功夫： 首先因为他是成熟的，新的东西虽然好，但是要用得好，非常熟悉其原理才能体现出新的优势，而对于一个新手来说，熟悉都谈不上，哪里又谈得上精通。 老的东西是一个成熟的整体，而不仅仅是单方面的功能，即便可以用新的局部替代就的，但是有时候难以完全替代。这时候两个东西都要学，但是都搞不精。 未来 统计：目前该应用只是做了一个简单的计时和列表，但是还没有数据的统计功能，所以等过后空闲时，加上统计的功能 多任务：目前只能进行单任务，以后会增加多任务进行。其实个人挺推荐单任务，集中时间来做一个事情，才是最高效的 上架IOS和按照市场，目前其实APP是有的，但是由于缺乏移动端的微信SDK账户和相应的证书，无法上架。","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/tags/工具/"}]},{"title":"有偿问答平台","slug":"2019-04-10有偿问答平台","date":"2019-04-10T11:12:17.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/04/10/2019-04-10有偿问答平台/","link":"","permalink":"http://zhangweixi.github.io/2019/04/10/2019-04-10有偿问答平台/","excerpt":"","text":"项目简介在平常的工作中，经常会遇到一些问题，而这些问题可能一时无法从网上获取到现成的解决方案，或者寻找资源太麻烦，或者时间太紧，那么这时候尤其希望一个经验丰富的人能够指导一下。该平台因此而生，每个人的时间和知识都不是免费的，因此我们提倡进行有偿问答，该平台的主要作用是能否快速、可靠的解决问题。 答题规则 如果提问人还没有指定一个答题的人，那么每个人都可以申请回答这个问题 出题人通过与申请人的交流中，可以确定是否由改回答者来回答问题 如果确定了答题人，那么其他人可以与提问人交流，但是无法成为答题人，即使帮助提问人正确回答了问题，也无法得到相应的报酬 如果确定了答题人后，但是答题人最终无法提供正确答案，那么出题人可以另外选择答题人。 答题结束之后，出题人确定答题结束，答题人获得报酬，如果确定了答题人后超过10小时，出题人没有确定答题结果，那么系统将自动付出答谢费，在10小时之内，出题人可以提出延长时间，但最多延长10小时","categories":[{"name":"规划","slug":"规划","permalink":"http://zhangweixi.github.io/categories/规划/"}],"tags":[]},{"title":"运筹学主要概念","slug":"2019-03-20运筹学主要概念","date":"2019-03-20T17:56:29.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/20/2019-03-20运筹学主要概念/","link":"","permalink":"http://zhangweixi.github.io/2019/03/20/2019-03-20运筹学主要概念/","excerpt":"","text":"一、决策 不确定的条件下的有哪些决策条件有哪些？ 关键节点的节点时差 关键线路的线路时差 节点的最早开始时间 活动的专用时差 问答：能够缩短工程周期的方法有哪些？ 应用线性规划建立模型时的步骤有哪些？ 求解需求量小于供应量的运输问题需要做哪些？如虚设一个需求点 解释定性决策 经济订货量 表上作业法什么情况下判断当前运输方案为最优 解释专家小组法 解释线性规划的可行性 说明箭线式网络图 解释模拟 什么叫指数平滑法 边际贡献如何计算？答：销售收入-变动成本 七、网络计划技术 活动总时差：不延误项目完成日期的前提下，某活动可以推迟的时间比如要求你完成些一篇文章，15号必须交稿，凭你的能你，只需要5天就可以完成，今天刚好是3号，因此对于这个活动而言，最早开始时间（ES）是3号，等过5天工作完成，最早完成时间（EF）就是8号，但是根据依据，你只要15交稿就行呀，那么你的最迟完成时间（LF）就是15号，最迟开始时间（LS)就是10号，因此这个活动的总时差:$$TF=LS-ES=LF-EF=10-3=15-8=7$$ 自由时差：不影响紧后活动的最早开始时间比如你的文章规定15号必须截稿，然后交给编辑审稿，审稿的时间规定是4天内必须完成，实际2天就完成了，那么这个时候你的工作就会影响后面的工作的最早开始时间了，如果你8号完成，那么审稿就是9号开始，如果你15号完成，那么审稿最早16号开始，自由时差:$$FF=ES_j-EF_i$$ 综合名词解释： 定性决策：决策中主要依靠决策者或专家的智慧进行决策的一种方法 定性决策法的类型包括：德尔菲法，头脑风暴法，哥顿法，电子会议法 专家小组法：又名德尔菲法，召集对目标岗位有充分了解和深刻认识的专家，收集他们对目标岗位核心素质的看法和意见 线性规划的可行解：满足所有约束条件的任意一组决策变量的取值 线性规划的可行域：所有可行解组成的集合 指数平滑法：一种预测方法，当期的预测值=上一期的实际值系数+上一期的预测值（1-系数）$$Y_{t+1}^1=aY_t+(1-a)Y_t^1$$ 从此引出一个问题：用不同的方法来预测问题 对于报关费有个问题：如果年报关费费6%，","categories":[{"name":"运筹学","slug":"运筹学","permalink":"http://zhangweixi.github.io/categories/运筹学/"}],"tags":[{"name":"运筹学","slug":"运筹学","permalink":"http://zhangweixi.github.io/tags/运筹学/"}]},{"title":"Want To Do","slug":"2019-03-19Want-To-Do","date":"2019-03-19T13:44:10.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/19/2019-03-19Want-To-Do/","link":"","permalink":"http://zhangweixi.github.io/2019/03/19/2019-03-19Want-To-Do/","excerpt":"","text":"《时间手印》精确记录在某件事情上花的总时间 《中国事线》按时间的先后顺序编排中国历史大事件 《世界作家全录》收录世界上所有的作家，并列出他的著作和生平简介，以及主要的人际关系网络 《一步一步学语法》讲解语法知识，语法测试题，答案解析。目前看了很多语法内容平台，虽然有知识和问题和解答。但是对于像我这种英语不好的人来说，A,B,C,D好像都是对的，如果只是选择一个正确的答案还不够，我要知道错误的为什么错误才行","categories":[{"name":"规划","slug":"规划","permalink":"http://zhangweixi.github.io/categories/规划/"}],"tags":[]},{"title":"计算机网络原理相关问题","slug":"2019-03-18计算机网络原理","date":"2019-03-18T18:29:12.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/18/2019-03-18计算机网络原理/","link":"","permalink":"http://zhangweixi.github.io/2019/03/18/2019-03-18计算机网络原理/","excerpt":"","text":"一、传输层作用 复用分解 数据分组 建立连接 可靠传输 流量控制 相关问题 分解与复用的概念 多路复用：传输层协议从不同套接字收集应用进程发送来的数据块，并为每个数据块封装上首部信息构成报文段，然后将报文传递给网络层，这就是多路复用。 多路分解：接受主机的传输层从网络层接收到数据报之后，根据报文头部的端口，将数据分发给不同的套接字，实现分解。 TCP握手过程和挥手过程讲解一：重点在报文的解读讲解二：重点在挥手过程的理解关于挥手过程的通俗理解：假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ TCP握手阶段会做些什么预备工作？挥手过程做了些什么工作？尽管从上面的文章中看出了连接的步骤和几个关键的确认值等，但是对于实际的作用，并没有从中体现出来，连接到底何用呢？ 交换窗口大小：客户端向服务器发送一个SYN置位的TCP报文，其中包含连接的初始序列号x和一个窗口大小（表示客户端上用来存储从服务器发送来的传入段的缓冲区的大小）服务器收到客户端发送过来的SYN报文后，向客户端发送一个SYN和ACK都置位的TCP报文，其中包含它选择的初始序列号y、对客户端的序列号的确认x+1和一个窗口大小（表示服务器上用来存储从客户端发送来的传入段的缓冲区的大小）。 获得最大分段信息MSS:MSS(Maximum Segment Size)并不是直接获取的,直接获取的是最大传输单元MTU，然后根据这个来计算MSS,改字段位于选项字段中 数据报分组大小是根据什么分组的，分组与网络层的分段有何区别？详解报文分组和分片的区别 TCP报文详细信息报文结构的详细介绍 DHCP协议：主要讲解了一个刚刚加入网络的计算机是如何获得一个IP地址的流程NAT:主要讲解了在一个局域网中，某台主机是通过什么样的方式访问公网的，以及通过什么样的方式公网可以访问局域网内的某台主机ICMP协议：主要是当数据再传输过程中发生错误的时候，如何向源主机报告错误信息。 二、网络层作用 维护路由表 路由转发 拥塞控制 呼叫准入 建立连接 相关问题 网络层对数据进行封装的时候首先就需要IP地址，域名解析过程？查看域名解析过程 域名是如何分类的？网络和主机数量如何确定？子网如何划分，路由聚合如何实现？ IPV4数据报结构查看数据报结构1查看数据报结构2 虚电路的作用电路交换网络、虚电路网络和数据报网络的区别比较 网络拥塞如何感知？网络拥塞成因与处理 流量调节的方法有哪些？ 初始接入网络的主机是如何获得IP地址的？动态主机设置协议DHCP(Dynamic Host Configuration Protocol)工作原理 局域网内的主机是如何将数据发送到公网的，公网的数据又如何发送到局域网中的主机来？网络地址转换NAT(Network Address Translation)工作原理 路由线路上发生错误了如何处理？Internet控制报文协议ICMP (Internet Control Message Protocol) 常用的路由算法？链路状态路由选择算法：Dijkstra算法距离向量路由选择算法层次路由选择算法 你知道哪些路由算法是层次路由选择算法吗？理解Internet路由，RIP,OSPF,BGPInternet路由协议 三、数据链路层相关问题 一个公司只拉了一条网线，无数的电脑是如何通过一条线将数据传输出去的？各种复用技术 MAC地址是什么鬼？为什么有了IP还需要MAT地址？MAC地址的意义及作用有了 IP 地址，为什么还要用 MAC 地址 网络会出现时好时坏的情况，网络是如何保证检查传输是否出错，以及如何面对出错这个问题的？差错控制 每台电脑是想往网络上发生数据就发吗？如果不是是怎么控制的？多路访问控制(MAC)协议 你的主机是如何知道你对面的小姐姐的主机的MAC地址的（肯定不是她告诉的）？ARP（Address Resolution Protocal）地址解析协议,工作在局域网：图解APR协议1图解APR协议2图解APR协议3图解APR协议4图解APR协议5 mac地址用于数据帧，Ip地址是用于数据报，如何理解？ 如果只告诉你一个MAC地址，如何去找到对应的IP地址呢？RARP(Reverse Address Resolution Protocal),逆地址解析协议：从名字可以看出来是ARP想对应的协议，这个协议是通过mac地址查找目标主机的IP地址，其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的BOOTP或DHCP所取代ARP（地址解析协议）和RARP（逆地址解析协议） 物理层 网络线路的物理层特性分别是哪些？ 解释：频分多路复用，同步时分多路复用，波分多路复用，异步时分多路复用 相关问题？ 数据在物理层的同步和异步传输有什么区别？答：时钟的要求不同，同步要求收发端时钟一致，而异步则不需要，异步以字符为单位，在前后加开始和结束标记，而同步以帧为单位，同步的发送效率高于异步 网络协议的三要素是什么？ 语义：说明要发送些什么内容，需要发出何种控制信息，以及完成的动作与做出的响应，列如IPV4协议需要源IP地址，目的IP地址等等 语法：用户数据与控制信息的结构和格式。如IPV4中的源IP地址和目的IP地址，可是谁在前谁在后，应该有一个结构的，就像英语有主语，宾语，谓语，怎么样才是一个正确的句子呢，语法规定：主语+谓语+宾语 时序：规定了彼此交换的次序 3.物理层的4个特性具体作用？ 机械特性：形状和尺寸、引线数目和排列、固定和锁定装置 电器特性：接口是为了通电的，通电范围是什么，最大最小多少由电器特性所规定 功能特性：电压有高有低，但是分别代表什么意思呢？由功能特性决定 规程特性：指明对于不同功能的各种可能事件的出现顺序。指明利用接口传输比特流的全过程及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式，即在物理连接建立、维持和交换信息时，DTE/DCE双方在各自电路上的动作序列。 物理层常见协议答：协议有RS-232-C,RS-449等 HDLC的的控制帧有几个不同的类型，分别表示什么，HDLC与PPP的区别？ 编号 名称 作用 0xxxxxxx 信息帧 表示传递的是正式数据 10xxxxxx 监控帧 差错检测和流量控制 11xxxxxx 无编号帧 建立连接的时候 TCP/IP模型组成和OSI模型的对应比较。TCP/IP由4层构成：应用层，传输层，网络互联层，网络接入层，网络互联层对应于OSI模型的网络层，而网络接入层则对应OSI模型的数据链路层和物理层 TCP/IP OSI 应用层 应用层 传输层 传输出 网络互联层 网络层 网络接入层 数据链路层、物理层 几个计算题： 根据带宽和调制电平位计算数据传输速率 延时计算 根据发送时间和传输速度计算传输速率","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://zhangweixi.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://zhangweixi.github.io/tags/计算机网络/"}]},{"title":"MySql删除重复数据","slug":"2019-03-14MySql删除重复数据","date":"2019-03-14T17:23:28.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/14/2019-03-14MySql删除重复数据/","link":"","permalink":"http://zhangweixi.github.io/2019/03/14/2019-03-14MySql删除重复数据/","excerpt":"","text":"删除重复数据，保留ID最大的","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"一张数据表的字段太多会造成什么影响？","slug":"2019-03-14一张数据表的字段太多会造成什么影响？","date":"2019-03-14T16:36:08.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/14/2019-03-14一张数据表的字段太多会造成什么影响？/","link":"","permalink":"http://zhangweixi.github.io/2019/03/14/2019-03-14一张数据表的字段太多会造成什么影响？/","excerpt":"","text":"待续…","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"MySQL:如何维护数据字典和索引","slug":"2019-03-14MySQL-如何维护数据字典和索引","date":"2019-03-14T16:33:47.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/14/2019-03-14MySQL-如何维护数据字典和索引/","link":"","permalink":"http://zhangweixi.github.io/2019/03/14/2019-03-14MySQL-如何维护数据字典和索引/","excerpt":"","text":"关于数据字典关于索引推荐一个索引分析工具 如何维护表结构合适的操作","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"Mysql字段类型选择","slug":"2019-03-14Mysql字段类型选择","date":"2019-03-14T15:00:10.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/14/2019-03-14Mysql字段类型选择/","link":"","permalink":"http://zhangweixi.github.io/2019/03/14/2019-03-14Mysql字段类型选择/","excerpt":"","text":"如何为数据选择合适的字段类型一、选择合适的字段类型有什么好处？ 不同的字段类型会占用不同的存储空间，如果字段类型选择正确了，从而可以减少磁盘，进而减少购买磁盘的钱 不同的字段类型在查询的时候会有不同的效率，因而选择合适的字段可以提高查询效率 二、选择字段的原则当一个字段可以使用多种类型时，那么应该使用什么样的原则最好呢？选择的顺序如下： 数字 日期 或者 二进制 字符 下表是每种类型占用空间列表： 类型 占用空间 示例 tinyint 1字节 常用与布尔类型，或者状态 smallint 2字节 mediumint 3字节 int 4字节 bigint 4字节 date 3字节 timestamp 4字节 datetime 8字节 对于相同级别的数据类型，应该选择占用空间小的。 三、事例证明","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"}]},{"title":"常用数据结构","slug":"2019-03-08常用数据结构","date":"2019-03-08T15:29:20.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/08/2019-03-08常用数据结构/","link":"","permalink":"http://zhangweixi.github.io/2019/03/08/2019-03-08常用数据结构/","excerpt":"","text":"使用PHP的形式来实现面向对象式子的高级数据结构，需要安装php扩展ds,ds扩展已经提供了大量的常见数据结构 1.Vector1.1. 初始化 $vector = new \\Ds\\Vector(); 1.2. 添加元素 //单个元素 $vector-&gt;push(&#39;a&#39;); //多个元素 $vector-&gt;push(&#39;c&#39;,&#39;d&#39;); 更多详细 http://php.net/manual/zh/book.ds.php","categories":[{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/categories/PHP/"},{"name":"数据结构","slug":"PHP/数据结构","permalink":"http://zhangweixi.github.io/categories/PHP/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhangweixi.github.io/tags/数据结构/"}]},{"title":"服务器环境必须要做的事情","slug":"2019-03-06服务器环境必须要做的事情","date":"2019-03-06T17:13:45.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/06/2019-03-06服务器环境必须要做的事情/","link":"","permalink":"http://zhangweixi.github.io/2019/03/06/2019-03-06服务器环境必须要做的事情/","excerpt":"","text":"对服务器的运行状态进行监控，否则什么是服务器停止工作了都不知道 对磁盘文件进行监控，如果磁盘空间不足，会导致MySQL停止执行，查询语句是可以的，对数据变动的语句则会处于锁定状态 一切服务环境配置到启动脚本中，防止服务器启动后但是某些服务忽略了而没有开始工作","categories":[{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/tags/linux/"}]},{"title":"浅析算法—查找","slug":"2019-03-03浅析算法—查找","date":"2019-03-03T12:32:55.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/03/2019-03-03浅析算法—查找/","link":"","permalink":"http://zhangweixi.github.io/2019/03/03/2019-03-03浅析算法—查找/","excerpt":"","text":"二分找找法","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangweixi.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangweixi.github.io/tags/算法/"}]},{"title":"解决docker容器内部无法联网","slug":"2019-03-03Docker-笔记","date":"2019-03-03T02:20:25.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/03/2019-03-03Docker-笔记/","link":"","permalink":"http://zhangweixi.github.io/2019/03/03/2019-03-03Docker-笔记/","excerpt":"","text":"docker容器内部无法联网：加启动参数–net host,如:docker run -it -P –net host web /bin/bash","categories":[{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/tags/Docker/"}]},{"title":"浅析算法——排序","slug":"2019-03-01浅析算法——排序","date":"2019-03-01T22:49:31.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/01/2019-03-01浅析算法——排序/","link":"","permalink":"http://zhangweixi.github.io/2019/03/01/2019-03-01浅析算法——排序/","excerpt":"","text":"冒泡排序 快速排序法 从要排序的列表中选择一个基准数，随机，没有任何要求 对除了基准数之外的列表进行遍历，将比基准数小的放在基准数的左端，大的放在基准数的右边 将左右两边的数按照1-2的步骤执行（递归），然后按照左-基准数-右的顺序连接起来 插入排序法","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangweixi.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangweixi.github.io/tags/算法/"}]},{"title":"ajax跨无法下载文件","slug":"2019-03-01ajax跨无法下载文件","date":"2019-03-01T17:46:36.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/01/2019-03-01ajax跨无法下载文件/","link":"","permalink":"http://zhangweixi.github.io/2019/03/01/2019-03-01ajax跨无法下载文件/","excerpt":"","text":"服务器A:http://www.xx.com:80服务器B:http://www.xx.com:8080 当在服务器A的客户端使用ajax方式从服务器B下载文件时，无法正常下载，但是如果在浏览器中直接输入URL，则完全正常下载","categories":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/tags/JS/"}]},{"title":"【顶置】日常查阅工具","slug":"2019-03-01工具篇","date":"2019-03-01T00:27:18.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/03/01/2019-03-01工具篇/","link":"","permalink":"http://zhangweixi.github.io/2019/03/01/2019-03-01工具篇/","excerpt":"","text":"在线写作平台https://www.writeathon.cn/https://www.teakki.com API接口文档https://apizza.net 写作文档查阅Mathjax使用查阅markdown 代码美化https://carbon.now.sh","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/tags/工具/"}]},{"title":"Angular锦集","slug":"2019-02-27Angular锦集","date":"2019-02-27T15:28:18.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/02/27/2019-02-27Angular锦集/","link":"","permalink":"http://zhangweixi.github.io/2019/02/27/2019-02-27Angular锦集/","excerpt":"","text":"angularjs上传图片$scope.upload = function(){ var form = new FormData(); //添加图片 var file = document.getElementById(&#39;eleId&#39;); form.append(&#39;file&#39;,file); //添加其他参数 form.append(&#39;name&#39;,&#39;zhangweixi&#39;); var url = &quot;http://www.xx.com/upload&quot;; $http({ method:&quot;post&quot;, url:url, data:form, headers:{&quot;Content-Type&quot;,undefined}, transformRequest:angular.identify }).success(function(res){ //do something }); }","categories":[],"tags":[]},{"title":"django学习笔记","slug":"2019-02-26django学习笔记","date":"2019-02-26T13:32:30.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/02/26/2019-02-26django学习笔记/","link":"","permalink":"http://zhangweixi.github.io/2019/02/26/2019-02-26django学习笔记/","excerpt":"","text":"一、时间 将数据库的DateTimeField字段的日期格式化为:”2019-01-01 13:04:45”#字段.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)，如果有个产品模型 goods = GoodsModel.objects().get(id=1) goods.created_at = goods.created_at.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) ``` 二、数据库2.1. django模型中有表的字段和Python关键字冲突时的处理方式?","categories":[{"name":"Python","slug":"Python","permalink":"http://zhangweixi.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zhangweixi.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"http://zhangweixi.github.io/tags/django/"}]},{"title":"普通家庭如何面对突来的风险","slug":"2019-02-21普通家庭如何面对突来的风险","date":"2019-02-21T18:01:56.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/02/21/2019-02-21普通家庭如何面对突来的风险/","link":"","permalink":"http://zhangweixi.github.io/2019/02/21/2019-02-21普通家庭如何面对突来的风险/","excerpt":"","text":"今年的春天雨甚多这两天在图书馆里看书，内心颇为不安，时而看着看着就想到其他事情去了。今天图书馆的楼上，传来一阵阵的小女孩的歌声，心中不免在想，当孩子就是好呀，责任少，欢乐多！ 几件不安的事情 二婶在工地发生了很严重的意外，导致骨头和肺部严重受伤（据堂哥描述为背部骨头折断刺伤了肺），现在一直在ICU里等待好转一些才能进行手术。 我表弟的妻子为病的缘故造成孩子早产一至两月，现今孩子躺在保温箱里，他妻子则也病得格外严重，母子二人一日医药费就得数万元（据表弟给的医药单显示7万左右），这表弟在初中时，他爸就因病去世了。 我的奶奶因为炎症导致从元宵之前就开始住院，好的是今天中午打电话回去说她今天可以出院了 我爸妈都还没有找到事情做，年龄大以及身体上某些缘故，到处都难以找到合适的事情。 令人心虚的救护车去年的某一天，我在朋友圈看见二哥发了一张二伯吐血的照片，后来又听母亲说在浙江打工的大叔回老家（他家现住遵义，但是回到出身之地金竹园）养病去了，听到这消息感到格外惊异，他身体一直很好，怎会突然得病呢？ 某日早晨上班的时候从地铁站出来，马路上车很多，一辆救护车夹在车流中不停的响着，当时听得我心里格外慌张，身体也跟着颤抖了几下。 是的，无忧的日子已经远去了，对于家的责任正在悄然到来。 去年，因为扶贫搬迁，我们那里有好几户人家都搬迁到了县城里面，就在年末，堂哥刚好完成了新婚。这一切看起来似乎都不断朝着好的方向发展，然而事实情况是，很多以往在农村靠地为生的人搬到了略有一点城镇化的地方，却找不到事情做了，尽管政府也在努力，可是面对有限的劳力需求，似乎也起不了多大的作用。如若再使人们回去种地，则也不现实，老家的房子已经被拆，无处栖身，再则每日几十公里的距离来往是不可取的。 这些现象使得我在思考一个问题，一个经济不好的家庭，家庭成员往往会为了改善经济状况而去做一些具有高风险的事情，在此期间，人们很难意识到风险，即便有的风险明明知道，也会怀着侥幸的心里。如果运气好，这一切看似顺顺利利，可如果遇到不幸的事情，之前改善经济的努力都因此而付诸东流，并且再次回到起点。 常常思考一个问题，是否现在就应该回家说来惭愧，现在的工作，除了每日踩着时间固定上下班，领着固定的工资，其他的意义何在呢？谈不上未来，谈不上前途。我常常在想一个问题，现在是否应该回家。一个人的发展对家庭的作用实在是太小了，就一般家庭而言，如果想要改善状况，不能依靠一个人的发展，必须得带动所有人，才能真正的改变，否则，从总体上而言，那就等于拆东墙补西墙。可是，如果回去该如何发展呢？这也是一个很棘手的问题，并不是说想回就回，如果贸然行事，而又只能徒增负担。 一个普通家庭如何增加抵抗风险的能力呢？如果一个家庭中遇到某位成员得了一场大病，这常常会将这个家庭拖入到贫困的深渊中。那么，到底有没有什么方法，当大病来的时候一定可以顶住，而不至于给家庭带来严重的创伤呢？商业保险到底有多大的作用，是否可靠，又如何能够让普通家庭产生这种购买商业保险的意识呢?","categories":[{"name":"生活","slug":"生活","permalink":"http://zhangweixi.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://zhangweixi.github.io/tags/生活/"}]},{"title":"可靠数据传输基本原理","slug":"2019-01-24可靠数据传输基本原理","date":"2019-01-25T01:00:00.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/01/25/2019-01-24可靠数据传输基本原理/","link":"","permalink":"http://zhangweixi.github.io/2019/01/25/2019-01-24可靠数据传输基本原理/","excerpt":"","text":"环境假设先假设我们有一个文件需要从计算机A传输到计算机B，而且这个文件非常大，不可能一次传输就完成，由此可想而知，这个文件就需要拆分成很多分，但是这里有个问题，虽然说是很多分，那到底是多少份呢？网络数据传输中是如何定义的？请看网络数据传输的最小单位。 设要传的字符长度为m*n=l,如果每次只能传输n个字符，那么就需要传输m次，在理想情况下，l个字符只需要按照顺序从A依次传输给B，那么事情就完成了，而现实情况却并么有这么理想，有可能会发送以下错误： 发送的过程中数据被改变（信号干扰之类的原因） 后发的数据比先发的更早到达 发送过程中数据丢失了 解决数据被改变如果从PA发送字符串aabbcc发送到PB后变成了aaddcc,PB要能够识别出来数据有差错，不能够接收，可以使用校验码的方式，使用某种算法将发送的字符串进行计算，将计算的结果附加在原字符串的尾部，这样当PB接受到数据后，把前面的字符串再用同样的算法来计算，如果和后面的校验和一致的话，那么就说明数据是正确的。 如果数据是正确的，则PB告诉PA，数据正确，可以发送下一段如果数据是错误的，则PB告知PA，数据错误，需要从新发送 解决顺序错乱PA中的文件中的字符串是有顺序的，如果PA先发出的数据晚到，那肯定会造成数据段之间错误，使得数据丢失正确的信息，这个时候采用的策略就是每次发送的数据都添加一个序号，当PB接收完所有的数据后再进行排序 由此而衍生出一个问题，PB接收到的数据是暂存起来的，并没有立刻将数据交给应用程序，暂存肯定需要存储的地方，如果PA发送的文件是一个很大的文件，比如PB的内存是8G,而传输的文件是10G,那么这样的问题又如何处理呢？ 问题：大文件如何处理？ 解决数据丢失数据从PA发送到PB，无论数据是否正确，PB都能够得到这个信息，并依据这个来对PA进行一个反馈，但是如果数据丢失了，PB根本就不知道有数据传输给它，所以它也无从去通知PA传输结果，造成PA处于一直等待状态中，要想解决这个问题，只需要在PA端设置一个定时器，如果指定的时间内无法得到一个来自于PB的反馈，则说明数据在传输过程中丢失了，可据此重新传输一次，但是这里指定多少时间合适是一个问题？如果时间太短，则会造成不断的重复发送数据，如果时间太长，又造成传输速率太低 问题：设置多长时间合适？ 此外，PB还得有一个检查重复的功能，如果PB的反馈还没有达到PA，但是却又超过了设定的设计，PA就视为丢失了数据，然后重新发起一次新的传输，因此会造成数据重复的情况，不过这个依然可以使用序号来防范 总结通过以上我们可以发现，发送端要发送下一个报文的时候，必须得等到接受端的一个确认信息，而且是一个串行发送的方式，可想而知，这得有多么慢呢？在等待确认信息的过程中，发送方一直处于等待状态中，那么是否有办法可以提高发送效率呢？请看网络传输之BNB协议","categories":[],"tags":[]},{"title":"挤在最门边的人","slug":"2019-01-24挤在最门边的人","date":"2019-01-24T10:07:00.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/01/24/2019-01-24挤在最门边的人/","link":"","permalink":"http://zhangweixi.github.io/2019/01/24/2019-01-24挤在最门边的人/","excerpt":"","text":"地铁上或者公交车上经常会出现一种情况，门口处挤得水泄不同，但是中间还有很多比较空旷的位置,资源配置的问题在很多问题上都存在，可是作为一个晚来的人，又如何获得更多的空间呢？ 其实生活中这样的现象非常多，大多数人去争夺很少的资源，而少部分人拥有大量的资源","categories":[{"name":"生活","slug":"生活","permalink":"http://zhangweixi.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://zhangweixi.github.io/tags/生活/"}]},{"title":"那些一定要做的事情，尽早完成","slug":"2019-01-24那些一定要做的事情，尽早做","date":"2019-01-24T00:00:01.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/01/24/2019-01-24那些一定要做的事情，尽早做/","link":"","permalink":"http://zhangweixi.github.io/2019/01/24/2019-01-24那些一定要做的事情，尽早做/","excerpt":"","text":"生活中有一些事情，无论或早或晚，有一天你总是要完成的，那么到底应该是尽早做还是一直等到最后的时间呢？ 这个话题当然不是一个绝对的答案，如果用现在的房价来看，那相对于前几年来说肯定是越早越好，而另一方面，如果当下你正想买一辆车，而且以后也是肯定会买的，那么到底是现在买还是以后买好呢，这恐怕得从多方面来考虑","categories":[{"name":"生活","slug":"生活","permalink":"http://zhangweixi.github.io/categories/生活/"}],"tags":[]},{"title":"计算机网络传输层是如何工作的","slug":"2019-01-23计算机网络传输层是如何工作的","date":"2019-01-23T22:00:01.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/01/23/2019-01-23计算机网络传输层是如何工作的/","link":"","permalink":"http://zhangweixi.github.io/2019/01/23/2019-01-23计算机网络传输层是如何工作的/","excerpt":"","text":"计算机是如何找到计算机的这个问题看起来很简单，就是每台计算机具有一个唯一的IP地址，但是有一点疑问是并入网络的计算机这么多，一台计算机广播整个网络，每天计算机都要检查是否是在呼叫自己，那么对于整个计算机网络而言，负担也是不可小瞧的。 当物流公司寄送快递的时候，并不是一个快递寄到每一个地方逐一询问，而是一开始就确定一个大的地方，按照这个逻辑，计算是否也有呢？ 发送的数据如何知道发送给哪一个应用程序一个进程监听一个端口吗如果一个进程监听一个端口，服务器的并发如何理解网络断开是什么意思？这里的网络断开并不是指网线断了或者WIFI断了的意思，而是指在计算机通信过程中，一方主动断开与另一方的连接，这个断开到底是什么意思呢？ 通常大家都知道两台计算机在正式进行传输数据之前，需要又一次握手协议，什么叫握手协议？握手握手，到底干了什么事情，如果不干事情的话，握手干什么呢，莫非像人一样是为了显得热情亲切吗？","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://zhangweixi.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://zhangweixi.github.io/tags/计算机网络/"}]},{"title":"Linux安装munin","slug":"2019-01-20Linux安装munin","date":"2019-01-20T20:46:25.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/01/20/2019-01-20Linux安装munin/","link":"","permalink":"http://zhangweixi.github.io/2019/01/20/2019-01-20Linux安装munin/","excerpt":"","text":"本文参考博客Ron Ngai的安装博客几指引下操作的，博客地址 安装系统：centos7 1.安装客户端[root@home] yum install munin-node 这个客户端不是任何人都能否来采集信息的，所以配置一个允许来采集的服务器的ip,编辑文件,由于是在一台服务器上，所以是127.0.0.1，如果不是一台，那么自行配置为你的服务端ip地址 [root@home] vim /etc/munin/munin-node.conf allow ^127\\.0\\.0\\.1$ allow ^::1$ 配置好了，那么就启动呗，操作命令有： #service munin-node start #启动&lt;br/&gt; #service munin-node stop #停止&lt;br/&gt; #service munin-node restart #重启&lt;br/&gt; 2.安装服务端程序 [root@home] yum install munin 安装完成之后，会产生如下文件： [root@home] ll /usr/bin | grep munin -rwxr-xr-x 1 root root 4258 Nov 24 15:54 munin-check -rwxr-xr-x 1 root root 654 Nov 24 15:54 munin-cron -r-xr-xr-x 1 root root 3351 Nov 24 15:53 munindoc &nbsp;说明：这个软件并不是常驻内存的，所以每次运行都需要执行一个命令，而按作者原本的意思是软件安装完成后会自动在系统的定时任务里面添加一条记录，但是失败的话就不一定了，定时任务如下：&nbsp; 1 7 * * * curl http://www.xx.com/api/speed/admin/create_paper * * * * * su munin /usr/bin/munin-cron #munin新增的任务 但是:如果没有呢，那很有可能是失败了，这个时候去手动执行一次这个命令，注意不要用root用户直接执行，要使用munin用户执行，如果有问题的话会提示错误的，不管他是否工作，咱们先做一个配置，配置服务端在正常的情况下去采集某台服务器的信息: [root@home] vim /etc/munin.conf [local.127-0-0-1] #括号里面的名词可以随便写，那只是作为一个区分各个被监控主机的名字,下面的ip改成您的ip address 127.0.0.1 use_node_name yes 如果出错，安装一下这个软件试试： [root@home] yum install zlib 3.验证结果如果现在一切没有问题的话，那么就会有结果产生了，产生的结果保存在【/var/www/html/munin】,如果里面有很多html文件的话，那么就算成功了，如果没有呢，那么再次手动执行一下服务端程序，再看看 产生结果后，这个时候只需要将这个目录配置成可以用web访问的方式就可以了，具体可参看lnmp环境搭建和虚拟机配置","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhangweixi.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/tags/linux/"}]},{"title":"服务端如何维护多版本的API接口","slug":"2019-01-05服务端如何维护多个API版本的代码","date":"2019-01-05T14:00:00.000Z","updated":"2021-04-19T07:47:00.724Z","comments":true,"path":"2019/01/05/2019-01-05服务端如何维护多个API版本的代码/","link":"","permalink":"http://zhangweixi.github.io/2019/01/05/2019-01-05服务端如何维护多个API版本的代码/","excerpt":"","text":"开发API接口的时候经常会遇到多个版本的客户端，如果不是特别严重的问题，又不能强制客户端升级，那么这个时候就会产生一个问题，不同版本的客户端需要不同版本的API接口与之对应 对此，我们常用的方式有哪些呢？1.在代码中判断版本if($v== &quot;v1&quot;){ //执行V1版本的逻辑 }elseif($v == &quot;v2&quot;){ //执行V2版本的逻辑 } 2.每个版本使用独立的代码controllers ---- V1 -------- IndexController.php ---------TestController.php ----V2 --------- IndexController.php --------- TestController.php在这里，V2版本的代码是通过复制V1的代码而来的 3.后续版本继承前面的版本controllers ---- V1 -------- IndexController.php ---------TestController.php ----V2 --------- IndexController.php --------- TestController.phpV1的代码//IndexController.php namespace Controllers/V1; class IndexController { public function method1(){ //do something } } V2的代码namespace Controllers/V2; use Controllers/V1/IndexController; class IndexController extends IndexController{ //v2 版本新增内容 public function medhtod2(){ //do something } } 4.使用路由控制文件结构 controllers ----RootController.php ---- V1 -------- IndexController.php ---------TestController.php ----V2 --------- IndexController.php --------- TestController.php3.1 假设路由是这样的:https://www.xx.com/api/v1/controller/action 3.2 这里只需要配置一个路由就行,我们将所有的请求都路由到RootController的action方法中 //如请求:http:xx.com/api/v1/user/users Route::any(&quot;api/{version}/{controller}/{action}&quot;,&quot;Controller/RootController@action&quot;) 3.3 在action方法中，我们要进行判断 namespace Controllers; use Request; class RootController{ public function action(Request $request,$version,$controller,$action){ $vCode = substr($version,1,1); $controller = $controller.&quot;Controller&quot;; while(true){ $version = &quot;V&quot;.$vCode; $class = &quot;Controllers\\Api\\&quot;.$version.&quot;\\&quot;.$controller&quot;; if(class_exists($class)){ $class = new $class(); if(method_exists($class,$action)){ return $class-&gt;$action(); } } if($vCode &gt; 2){ $vCode--; cotinue; } die(&quot;not fund&quot;); } } } 总结在第4中方法中，不同版本直接的代码及没有继承，也没有完全复制，并且代码也不显得冗余，是一种值得考虑的方式（本例代码使用的是laravel框架）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/tags/PHP/"}]}],"categories":[{"name":"规划","slug":"规划","permalink":"http://zhangweixi.github.io/categories/规划/"},{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/categories/JS/"},{"name":"Linux","slug":"Linux","permalink":"http://zhangweixi.github.io/categories/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/categories/MySQL/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://zhangweixi.github.io/categories/嵌入式/"},{"name":"项目管理","slug":"项目管理","permalink":"http://zhangweixi.github.io/categories/项目管理/"},{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/categories/工具/"},{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/categories/PHP/"},{"name":"C","slug":"C","permalink":"http://zhangweixi.github.io/categories/C/"},{"name":"Python","slug":"Python","permalink":"http://zhangweixi.github.io/categories/Python/"},{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/categories/Docker/"},{"name":"MySQL","slug":"Docker/MySQL","permalink":"http://zhangweixi.github.io/categories/Docker/MySQL/"},{"name":"Docker","slug":"MySQL/Docker","permalink":"http://zhangweixi.github.io/categories/MySQL/Docker/"},{"name":"机器学习","slug":"机器学习","permalink":"http://zhangweixi.github.io/categories/机器学习/"},{"name":"小技巧","slug":"小技巧","permalink":"http://zhangweixi.github.io/categories/小技巧/"},{"name":"运筹学","slug":"运筹学","permalink":"http://zhangweixi.github.io/categories/运筹学/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://zhangweixi.github.io/categories/计算机网络/"},{"name":"数据结构","slug":"PHP/数据结构","permalink":"http://zhangweixi.github.io/categories/PHP/数据结构/"},{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/categories/linux/"},{"name":"算法","slug":"算法","permalink":"http://zhangweixi.github.io/categories/算法/"},{"name":"生活","slug":"生活","permalink":"http://zhangweixi.github.io/categories/生活/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://zhangweixi.github.io/categories/计算机基础/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhangweixi.github.io/tags/JS/"},{"name":"linux","slug":"linux","permalink":"http://zhangweixi.github.io/tags/linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhangweixi.github.io/tags/MySQL/"},{"name":"项目管理","slug":"项目管理","permalink":"http://zhangweixi.github.io/tags/项目管理/"},{"name":"工具","slug":"工具","permalink":"http://zhangweixi.github.io/tags/工具/"},{"name":"PHP","slug":"PHP","permalink":"http://zhangweixi.github.io/tags/PHP/"},{"name":"STM32","slug":"STM32","permalink":"http://zhangweixi.github.io/tags/STM32/"},{"name":"C","slug":"C","permalink":"http://zhangweixi.github.io/tags/C/"},{"name":"python","slug":"python","permalink":"http://zhangweixi.github.io/tags/python/"},{"name":"Docker","slug":"Docker","permalink":"http://zhangweixi.github.io/tags/Docker/"},{"name":"机器学习","slug":"机器学习","permalink":"http://zhangweixi.github.io/tags/机器学习/"},{"name":"小技巧","slug":"小技巧","permalink":"http://zhangweixi.github.io/tags/小技巧/"},{"name":"代码规范","slug":"代码规范","permalink":"http://zhangweixi.github.io/tags/代码规范/"},{"name":"运筹学","slug":"运筹学","permalink":"http://zhangweixi.github.io/tags/运筹学/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://zhangweixi.github.io/tags/计算机网络/"},{"name":"数据结构","slug":"数据结构","permalink":"http://zhangweixi.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://zhangweixi.github.io/tags/算法/"},{"name":"django","slug":"django","permalink":"http://zhangweixi.github.io/tags/django/"},{"name":"生活","slug":"生活","permalink":"http://zhangweixi.github.io/tags/生活/"}]}